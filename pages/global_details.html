<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Bike Share in San Francisco Bay Area</title>
    <link rel="stylesheet" href="../css/vis3.css">
</head>
<body>
    <div id="nav"></div>

    <div id="content" class="vis-grid">
        <div id="content-traffic">
            <h2>
                Global bike traffic for each
                <select name="content-traffic-class" id="content-traffic-class" autocomplete="off">
                    <option value="city" selected>City</option>
                    <option value="station">Station</option>
                </select>
            </h2>
            
            <p>
                Sort by
                <select name="content-traffic-sort" id="content-traffic-sort" autocomplete="off">
                    <option value="alphabetic" selected>Alphabetic</option>
                    <option value="total_trips">Total trips</option>
                    <option value="incoming_trips">Incoming trips</option>
                    <option value="outgoing_trips">Outgoing trips</option>
                </select>

                <input type="checkbox" name="content-traffic-sort-asc" id="content-traffic-sort-asc" checked>
                Ascending
            </p>

            <div id="content-traffic-vis"></div>
        </div>

        <div id="content-client-total-trips">

            <div id="content-client-total-trips-vis"></div>
        </div>

        <div id="content-bike-usage">

            <div id="content-bike-usage-vis"></div>
        </div>

        <div id="content-client-length-trips">

            <div id="content-client-length-trips-vis"></div>
        </div>
    </div>

    <div id="filters"></div>

    <script src="https://cdn.jsdelivr.net/npm/jquery@3.7.1/dist/jquery.min.js"></script>
    <script src="http://d3js.org/d3.v6.js"></script>
    <script src="base.js"></script>
    <script src="charts/client_bar.js"></script>
    <script>

        // TODO: ascending checkbox not on by default
        // TODO: client type chart rects change position sometimes
        // TODO: client type chart legend makes no sense when it could be applied to X axis

        let data_update_callbacks = [];
        d3.select("#content").on("data-update", () => {
            data_update_callbacks.forEach((callback) => callback());
        });

        function visTraffic(metadata) {
            // Set the dimensions and margins of the graph
            const margin = {top: 10, right: 30, bottom: 200, left: 50};
            const width = 600 - margin.left - margin.right;
            const totalWidth = 3 * width;
            const height = 400 - margin.top - margin.bottom;

            const city_graph = d3.select("#content-traffic-vis").append("div");
            const station_graph = d3.select("#content-traffic-vis").append("div")
                .style("display", "none");  // hidden by default

            // Create a scrollable div which will contain the chart and X axis
            const station_scrollable_div = station_graph.append("div")
                    .style("overflow-x", "scroll")
                    .style("-webkit-overflow-scrolling", "touch")
                    .style("position", "absolute")
                    .style("z-index", 1)
                    .style("width", width + "px")
                    .style("height", (height + margin.bottom + margin.top) + "px")
                    .style("left", "60px");

            const station_scrollable_div_svg = station_scrollable_div.append("svg")
                    .attr("width", totalWidth)
                    .attr("height", height + margin.bottom + margin.top)
                    .style("display", "block");

            // Append the svg object to the respective section
            const station_outer_svg = station_graph
                .append("svg")
                .attr("width", width + margin.left + margin.right)
                .attr("height", height + margin.top + margin.bottom)
                .style("top", "0px")
                .append("g")
                .attr("transform", "translate(" + margin.left + "," + margin.top + ")");

            const x_axis_svg = station_scrollable_div_svg.append("g")
                    .classed("station-x-axis", true);
            const y_axis_svg = station_outer_svg.append("g");
            const bars_out_svg = station_scrollable_div_svg.append("g")
                    .classed("g-out", true);
            const bars_in_svg = station_scrollable_div_svg.append("g")
                    .classed("g-in", true);

            // NOTE: disadvantage of having the same array of stations: all stations will appear even if they have no trips for the given filters
            const stations_id_name_pairs = Object.entries(metadata["stations"]).map((s) => [s[0], s[1]["name"]]);
            const stations_names = stations_id_name_pairs.map((p) => p[1]);
            const stations_ids = stations_id_name_pairs.map((p) => p[0]);

            // Create X scale (necessary for the sorting methods)
            const x_max_length = 24;
            function truncate_station_name(station_name) {
                return (station_name.length > x_max_length) ? station_name.slice(0, x_max_length - 3) + "..." : station_name;
            }
            const x = d3.scaleBand()
                .domain(stations_names.map(truncate_station_name))
                .range([0, totalWidth])
                .padding([0.2]);

            // Input options callbacks
            d3.select("#content-traffic-class").on("change", function() {
                let traffic_type = this.value;
                switch (traffic_type) {
                    case "city":
                        station_graph.style("display", "none")
                        city_graph.style("display", "block")
                        break;
                
                    case "station":
                        city_graph.style("display", "none")
                        station_graph.style("display", "block")
                        break;

                    default:
                        console.log("ERROR: invalid class for traffic visualization")
                }
            });

            function sortContent(sort_type, sort_ascending) {
                let sort_function = undefined;

                switch (sort_type) {
                    case "alphabetic":
                        sort_function = (a, b) => sort_ascending ? d3.ascending(a.station, b.station) : d3.descending(a.station, b.station)
                        break;
                    
                    case "total_trips":
                        sort_function = (a, b) => sort_ascending ? d3.ascending(a.value_in + a.value_out, b.value_in + b.value_out) : d3.descending(a.value_in + a.value_out, b.value_in + b.value_out);
                        break;
                    
                    case "incoming_trips":
                        sort_function = (a, b) => sort_ascending ? d3.ascending(a.value_in, b.value_in) : d3.descending(a.value_in, b.value_in);
                        break;

                    case "outgoing_trips":
                        sort_function = (a, b) => sort_ascending ? d3.ascending(a.value_out, b.value_out) : d3.descending(a.value_out, b.value_out);
                        break;
                    
                    default:
                        console.log("ERROR: invalid sort type for traffic visualization");
                        return;
                }

                sorted_in = station_scrollable_div_svg
                    .selectAll("g.g-in")
                    .selectAll("rect")
                    .sort(sort_function);
                
                sorted_out = station_scrollable_div_svg
                    .selectAll("g.g-out")
                    .selectAll("rect")
                    .sort(sort_function);

                // It doesn't matter whether we use sorted_in or sorted_out
                stations_names_sorted = sorted_out.data().map((d) => truncate_station_name(d.station));

                x.domain(stations_names_sorted)
                d3.select(".station-x-axis")
                    .transition()
                    .duration(1000)
                    .call(d3.axisBottom(x));

                sorted_in
                    .transition()
                    .attr("x", (d, i) => x(truncate_station_name(d.station)) + x.bandwidth() / 2);
                sorted_out
                    .transition()
                    .attr("x", (d, i) => x(truncate_station_name(d.station)));
            }

            d3.select("#content-traffic-sort").on("input", function() {
                sortContent(this.value, d3.select("#content-traffic-sort-asc").property("checked"));
            });

            d3.select("#content-traffic-sort-asc").on("input", function() {
                sortContent(d3.select("#content-traffic-sort").node().value, this.checked);
            });

            // Color palette
            const color = d3.scaleOrdinal()
                    .domain(["start", "end"])
                    .range(['#e41a1c', '#377eb8']);

            // Add Legend
            var legend = station_outer_svg.append("g")
                    .attr("transform", "translate(" + (width - 100) + "," + 20 + ")")
                    .selectAll("g")
                    .data(color.domain().slice().reverse())
                    .enter().append("g")
                    .attr("transform", function(d, i) { return "translate(0," + i * 20 + ")"; });

            legend.append("rect")
                .attr("width", 18)
                .attr("height", 18)
                .attr("fill", color);

            legend.append("text")
                .attr("x", 24)
                .attr("y", 9)
                .attr("dy", ".35em")
                .style("text-anchor", "start")
                .text(function(d) { return d === "start" ? "Outgoing" : "Incoming"; });

            return (data) => {
                // Data processing for outgoing trips
                const start_station_counts = {};
                data.forEach(function(d) {
                    start_station_counts[d.start_station_id] = (start_station_counts[d.start_station_id] || 0) + d.total_trips;
                });
                
                // Data processing for incoming trips
                const end_station_counts = {};
                data.forEach(function(d) {
                    end_station_counts[d.end_station_id] = (end_station_counts[d.end_station_id] || 0) + d.total_trips;
                });

                let counts_data = stations_id_name_pairs.map(function(p) {
                    return { station: p[1], value_out: start_station_counts[p[0]] || 0, value_in: end_station_counts[p[0]] || 0 };
                });

                // Add X axis
                x_axis_svg
                    .attr("transform", "translate(0," + (height + margin.top) + ")")
                    .call(d3.axisBottom(x).tickSize(0))
                    .selectAll("text")
                        .attr("transform", "translate(0,5), rotate(-90)")
                        .style("text-anchor", "end");

                // Add Y axis
                const y = d3.scaleLinear()
                    .domain([0, d3.max(Object.values(start_station_counts).concat(Object.values(end_station_counts)))])
                    .range([height, 0]);

                y_axis_svg.call(d3.axisLeft(y));

                // Show the bars for outgoing trips
                bars_out_svg
                    .selectAll("rect")
                    .data(counts_data)
                    .join("rect")
                    .attr("x", function(d, i) { return x(truncate_station_name(d.station)); })
                    .attr("y", function(d) { return y(d.value_out) + margin.top; })
                    .attr("width", x.bandwidth() / 2)
                    .attr("height", function(d) { return height - y(d.value_out); })
                    .attr("fill", function(d) { return color("start"); });

                // Show the bars for incoming trips
                bars_in_svg
                    .selectAll("rect")
                    .data(counts_data)
                    .join("rect")
                    .attr("x", function(d, i) { return x(truncate_station_name(d.station)) + x.bandwidth() / 2; })
                    .attr("y", function(d) { return y(d.value_in) + margin.top; })
                    .attr("width", x.bandwidth() / 2)
                    .attr("height", function(d) { return height - y(d.value_in); })
                    .attr("fill", function(d) { return color("end"); });

                // Default sort
                sortContent("alphabetic", true);
                
                station_scrollable_div.node().scrollBy(0, 0);
            };
        }

        function visBikeUsage(metadata) {
            return () => null;
        }

        function visClientTotalTrips(metadata) {
            const chart_attributes = clientBarSetup("#content-client-total-trips-vis", 500, 300, 20, 20, 70, 70);

            return (data) => {
                // Extract the subscription_type column
                let subscriptionTypes = data.map(function(d) {
                    return d.subscription_type;
                });

                // Count occurrences of each label
                let labelCounts = {};
                subscriptionTypes.forEach(function(label) {
                    labelCounts[label] = (labelCounts[label] || 0) + 1;
                });

                clientBarUpdate(Object.entries(labelCounts), chart_attributes);
            };
        }

        function visClientLengthTrips(metadata) {
            const chart_attributes = clientBarSetup("#content-client-length-trips-vis", 500, 300, 20, 20, 70, 70);

            return (data) => {
                // Group data by subscription type and sum the duration for each group
                const groupedData = d3.group(data, d => d.subscription_type);

                // Calculate total duration for each subscription type
                const totalDurationBySubscription = new Map();

                groupedData.forEach((value, key) => {
                    const totalDuration = d3.sum(value, d => d.duration_avg);
                    totalDurationBySubscription.set(key, totalDuration);
                });

                // Create a simple array with values as the ratio of totalDurationBySubscription to the count of instances
                const ratioArray = Array.from(groupedData.keys()).map(key => totalDurationBySubscription.get(key) / groupedData.get(key).length);

                // Convert ratioArray to a Map
                const ratioMap = new Map(Array.from(groupedData.keys()).map((key, i) => [key, ratioArray[i]]));

                clientBarUpdate(Array.from(ratioMap.entries()), chart_attributes);
            };
        }

        function drawTripData(metadata, data, update_callbacks) {
            console.log("Loaded trip data");

            const dateParser = d3.utcParse("%Y-%-m-%-d");

            for (const d of data) {
                d["start_date"] = dateParser(d["start_date"]);
                d["end_date"] = dateParser(d["end_date"]);
                d["duration_avg"] = +d["duration_avg"];
                d["total_trips"] = +d["total_trips"];
            }

            function updateData() {
                console.log("Filtering data...");
                // TODO: include city information on trips, only have station
                const cityTraversalFilter0 = (d) => d.start_station_id == d.end_station_id;  // within cities
                const cityTraversalFilter1 = (d) => true;  // both
                const cityTraversalFilter2 = (d) => d.start_station_id != d.end_station_id;  // between cities

                const clientTypeFilter0 = (d) => d.subscription_type == "Customer";  // customer
                const clientTypeFilter1 = (d) => true;  // both
                const clientTypeFilter2 = (d) => d.subscription_type == "Subscriber";  // subscriber

                let cityTraversalFilter = (filter.cityTraversal == 0) ? cityTraversalFilter0 : ((filter.cityTraversal == 1) ? cityTraversalFilter1 : cityTraversalFilter2);
                let clientTypeFilter = (filter.clientType == 0) ? clientTypeFilter0 : ((filter.clientType == 1) ? clientTypeFilter1 : clientTypeFilter2);

                let dataFiltered = data.filter((d) => {
                    return d.start_date >= filter.timeStart && d.end_date <= filter.timeEnd && cityTraversalFilter(d) && clientTypeFilter(d);
                });
                console.log("Data filtered");

                update_callbacks.forEach((callback) => callback(dataFiltered));
            }

            console.log("Initializing visualizations (trip data)");
            data_update_callbacks.push(updateData)
            updateData();
        }

        console.log("Loading data...");

        trip_small_data = d3.csv("../data/trip_small.csv");

        // TODO: possible performance optimization: (pre-)sort trip data by date. With this, we don't need to filter, we can just use indexOf() and get the indices of the initial and end dates, and finally take the interval in between those indices (hint: use d3.bisector!)
        d3.json("../data/metadata.json")
            .then((metadata) => {
                setupFilters(metadata,
                    ["#content-traffic", "#content-client-total-trips", "#content-client-length-trips"],
                    ["#content-traffic", "#content-client-total-trips", "#content-client-length-trips"],  // NOTE: ideally the client-* graphs shouldn't be here, but it complicates stuff too much otherwise...
                    ["#content-traffic", "#content-client-total-trips", "#content-client-length-trips", "#content-bike-usage"]
                );

                const trip_data_draw_callbacks = [
                    visBikeUsage(metadata),
                    visTraffic(metadata),
                    visClientTotalTrips(metadata),
                    visClientLengthTrips(metadata)
                ];

                trip_small_data
                    .then((data) => drawTripData(metadata, data, trip_data_draw_callbacks))
                    .catch(function(err){console.log(err)});
            })
            .catch(function(err){console.log(err)});            

    </script>
</body>
</html>