<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Bike Share in San Francisco Bay Area</title>
</head>
<body>
    <div id="nav"></div>

    <div id="content" class="vis3-grid">
        <div id="content-traffic">
            <h2>
                Global bike traffic for each
                <select name="content-traffic-class" id="content-traffic-class">
                    <option value="city">City</option>
                    <option value="station">Station</option>
                </select>
            </h2>
            
            <p>
                Sort by
                <select name="content-traffic-sort" id="content-traffic-sort">
                    <option value="alphabetic">Alphabetic</option>
                    <option value="total_trips">Total trips</option>
                    <option value="incoming_trips">Incoming trips</option>
                    <option value="outgoing_trips">Outgoing trips</option>
                </select>

                <input type="checkbox" name="content-traffic-sort-asc" id="content-traffic-sort-asc" checked>
                Ascending
            </p>

            <div id="content-traffic-vis"></div>
        </div>

        <div id="content-client-total-trips">

            <div id="content-client-total-trips-vis"></div>
        </div>

        <div id="content-bike-usage">

            <div id="content-bike-usage-vis"></div>
        </div>

        <div id="content-client-length-trips">

            <div id="content-client-length-trips-vis"></div>
        </div>
    </div>

    <div id="filters">
        <div id="filter-city-traversal" class="filter-group">
            <div class="filter-label-left">Within <br> cities</div>
            <div class="slider-3-toggle">
                <div class="slider-3-toggle-middle-indicator"></div>
    
                <div class="slider-3-toggle-circle"></div>
    
                <div class="slider-3-toggle-clickable-areas">
                    <div class="slider-3-toggle-clickable-area-0"></div>
                    <div class="slider-3-toggle-clickable-area-1"></div>
                    <div class="slider-3-toggle-clickable-area-2"></div>
                </div>
            </div>
            <div class="filter-label-right">Between <br> cities</div>
        </div>

        <div id="filter-client-type" class="filter-group">
            <div class="filter-label-left">Customer</div>
            <div class="slider-3-toggle">
                <div class="slider-3-toggle-middle-indicator"></div>
    
                <div class="slider-3-toggle-circle"></div>
    
                <div class="slider-3-toggle-clickable-areas">
                    <div class="slider-3-toggle-clickable-area-0"></div>
                    <div class="slider-3-toggle-clickable-area-1"></div>
                    <div class="slider-3-toggle-clickable-area-2"></div>
                </div>
            </div>
            <div class="filter-label-right">Subscriber</div>
        </div>

        <div id="filter-time">
        </div>
    </div>

    <script src="https://cdn.jsdelivr.net/npm/jquery@3.7.1/dist/jquery.min.js"></script>
    <script src="http://d3js.org/d3.v6.js"></script>
    <script src="base.js"></script>
    <script>

        // Whenever the filters change, dispatch the custom event 'data-update' with the appropriate details.
        // D3 will listen for these events
        // const dataUpdateEvent = new CustomEvent('data-update', {detail: ...});

        // JS
        // Set filters' default values and get the filters' values if passed on the URL
        // The null dates will be set when the data is obtained and extents are extracted
        let filter = {
            cityTraversal: 0,
            clientType: 0,
            timeStart: null,
            timeEnd: null,
        }
        for (const [key, value] of currentURL.searchParams) {
            let parsedValue = null;

            // Number
            if (["cityTraversal", "clientType"].includes(key))
                parsedValue = +value;

            // Date
            else if (["timeStart", "timeEnd"].includes(key))
                parsedValue = new Date(+value);

            if (parsedValue != null)
                filter[key] = parsedValue
        }

        const changeSlider3ToggleState = function(filterId, state) {
            let left_position = 5 + 35 * state;
            // TODO: animation
            $(filterId).children(".slider-3-toggle").children(".slider-3-toggle-circle").css("left", left_position + "px");

            // Change the labels' color
            if (state <= 1) {
                $(filterId).children(".filter-label-left").css("color", "#0CA789");
            }
            else {
                $(filterId).children(".filter-label-left").css("color", "#000000");
            }

            if (state >= 1) {
                $(filterId).children(".filter-label-right").css("color", "#0CA789");
            }
            else {
                $(filterId).children(".filter-label-right").css("color", "#000000");
            }
            
            let filterElem = document.getElementById(filterId.slice(1));
            filterElem.value = state;
            filterElem.dispatchEvent(
                new Event('data-update')
            )
        }

        const sliderFilters = ["#filter-city-traversal", "#filter-client-type"];
        const filter_city_traversal_dependents = ["#content-traffic", "#content-client-total-trips", "#content-client-length-trips"];
        const filter_client_type_dependents = ["#content-traffic"];

        $(document).ready(function() {
            $("#filters").show();

            for (let filter of sliderFilters) {
                for (let i = 0; i < 3; i++) {
                    $(filter).children(".slider-3-toggle").children(".slider-3-toggle-clickable-areas").children(".slider-3-toggle-clickable-area-" + i).on("click", function() {
                        changeSlider3ToggleState(filter, i);
                    })
                }
            }
        });

        // D3

        // TODO: on brush single-click it disappears, let it stay?
        function addTimeSlider(initialLeft, initialRight, domain, callback) {
            const timeSliderWidth = 200
            const timeSliderHeight = 20
            const timeSliderLabelWidth = 100

            let timeFilterSvg = d3.select('#filter-time').append('svg')
                .attr('width', timeSliderWidth + timeSliderLabelWidth * 2)
                .attr('height', timeSliderHeight)

            const timeSlider = timeFilterSvg.append('g')

            let x = d3.scaleLinear()
                .domain(domain)
                .range([0, timeSliderWidth])

            timeSlider.selectAll('text')
                .data([[0, 15], [timeSliderWidth + timeSliderLabelWidth, 15]])
                .join('text')
                    .text('A')
                    .attr('x', (d) => d[0])
                    .attr('y', (d) => d[1])

            var brush = d3.brushX()
                .extent([[0, 0], [timeSliderWidth, timeSliderHeight]])
                .on('brush', brushed)
                .on('end', brushEnded)

            var brushGroup = timeFilterSvg.append('g')
                .attr('class', 'brush')
                .attr('transform', 'translate(' + timeSliderLabelWidth + ',' + 0 + ')')
                .call(brush)
            
            function brushed(event) {
                // Alternative: let selection = event.selection
                let selection = d3.brushSelection(this)
                if (selection == null)
                    return

                let range = selection.map(x.invert)
                
                timeSlider.selectAll("text")
                    .text(function(d, i) {
                        let date = new Date(range[i]);
                        return `${date.getUTCDate()}/${date.getUTCMonth() + 1}/${date.getUTCFullYear()}`
                    })
                
                // NOTE: comment if update every brush action is too heavy, and use brushEnded instead
                // callback(range[0], range[1])
            }

            function brushEnded() {
                let selection = d3.brushSelection(this)
                if (selection == null)
                    return

                let range = selection.map(x.invert)
                
                callback(range[0], range[1])
            }

            brush.move(brushGroup, [initialLeft, initialRight].map(x));

            return brush
        }

        function visTraffic() {
            return () => null;
        }

        function visBikeUsage() {
            // const width = 500;
            // const height = 300;
            // const margin = 50;

            // const colorOrdinal = d3.scaleOrdinal(d3.schemeCategory10);

            // const svg = d3.select('#content-traffic-vis').append('svg')
            //     .attr('width', width)
            
            // return (dataFiltered) => svg.selectAll("circle")
            //     .data(dataFiltered)
            //     .join("circle")
            //         .attr("cx", (d, i) => 25 + i * 50)
            //         .attr("cy", (d) => d.Numero_de_Alunos)
            //         .attr("r", 10)
            //         .attr("fill", (d) => colorOrdinal(d.city));

            return () => null;
        }

        function visClientTotalTrips() {
            // Set up SVG dimensions
            const margin = { top: 20, right: 20, bottom: 70, left: 70 };
            const w = 500 - margin.left - margin.right;
            const h = 300 - margin.top - margin.bottom;

            const svg = d3.select("#content-client-total-trips-vis")
                .append("svg")
                .attr("width", w + margin.left + margin.right)
                .attr("height", h + margin.top + margin.bottom)
                .append("g")
                .attr("transform", "translate(" + margin.left + "," + margin.top + ")");

            // TODO: just adding elements on data updates instead of actually updating what's already there
            return (data) => {
                // Extract the subscription_type column
                let subscriptionTypes = data.map(function(d) {
                    return d.subscription_type;
                });

                // Count occurrences of each label
                let labelCounts = {};
                subscriptionTypes.forEach(function(label) {
                    labelCounts[label] = (labelCounts[label] || 0) + 1;
                });

                let maxCount = Math.max(...Object.values(labelCounts));

                // Create rectangles based on the counts
                var rects = svg.selectAll("rect")
                    .data(Object.entries(labelCounts))
                    .join("rect")
                    .attr("x", function (d, i) {
                        return (i * (w / Object.keys(labelCounts).length));
                    })  
                    .attr("y", function (d) {
                        return h - (h * d[1] / maxCount);
                    })
                    .attr("width", (w / Object.keys(labelCounts).length - 1))
                    .attr("height", function (d) {
                        return (h * d[1] / maxCount);
                    })
                    .attr("fill", function (d) {
                        return "rgb(0, 100, " + Math.round((d[1] / maxCount) * 255) + ")";
                    });

                // Create x and y scales
                var xScale = d3.scaleBand()
                    .domain(d3.range(Object.keys(labelCounts).length))
                    .range([0, w])
                    .padding(0.1);

                var yScale = d3.scaleLinear()
                    .domain([0, maxCount])
                    .range([h, 0]);

                // Create x and y axes
                var xAxis = d3.axisBottom(xScale);
                var yAxis = d3.axisLeft(yScale);

                // Append x and y axes to the SVG
                svg.append("g")
                    .attr("transform", "translate(0," + h + ")")
                    .call(xAxis);

                svg.append("g")
                    .call(yAxis);

                // Add title to the chart
                svg.append("text")
                    .attr("x", w / 2)
                    .attr("y", -margin.top / 2.3)
                    .attr("text-anchor", "middle")
                    .style("font-size", "16px")
                    .text("Subscription Types Occurrences");

                // Add Y-axis title
                svg.append("text")
                    .attr("transform", "rotate(-90)")
                    .attr("y", -margin.left + 10)
                    .attr("x", -h / 2)
                    .attr("dy", "1em")
                    .style("text-anchor", "middle")
                    .style("font-size", "14px")
                    .text("Count");

                // Add legend
                let legend = svg.selectAll(".legend")
                    .data(Object.entries(labelCounts))
                    .join("g")
                    .attr("class", "legend")
                    .attr("transform", function(d, i) {
                        return "translate(0," + i * 20 + ")";
                    });

                legend.append("rect")
                    .attr("x", w - 18)
                    .attr("width", 18)
                    .attr("height", 18)
                    .style("fill", function(d) {
                        return "rgb(0, 100, " + Math.round((d[1] / maxCount) * 255) + ")";
                    });

                legend.append("text")
                    .attr("x", w - 24)
                    .attr("y", 9)
                    .attr("dy", ".35em")
                    .style("text-anchor", "end")
                    .text(function(d) {
                        return d[0] ;
                    });
            };
        }

        function visClientLengthTrips() {
            return () => null;
        }

        const data_draw_callbacks = [
            visTraffic(),
            visBikeUsage(),
            visClientTotalTrips(),
            visClientLengthTrips()
        ]

        // Trip data
        function draw(data) {
            console.log("Loaded data");
            console.log("Getting date extents...");
            const dateParser = d3.utcParse("%-m/%-d/%Y %H:%M");
            let dateStartExtent = d3.extent(d3.map(data, (d) => dateParser(d.start_date)));
            let dateEndExtent = d3.extent(d3.map(data, (d) => dateParser(d.end_date)));
            console.log("Date extents obtained")

            let dateExtent = [dateStartExtent[0], dateEndExtent[1]];
            
            if (filter.timeStart == null)
                filter.timeStart = dateExtent[0];
            if (filter.timeEnd == null)
                filter.timeEnd = dateExtent[1];

            function filterDataByCityTraversal(filterType) {
                if (filter.cityTraversal == filterType)
                    return;

                filter.cityTraversal = filterType;
                console.log("Filter by city traversal called");
                updateData(filter);
            }

            function filterDataByClientType(filterType) {
                if (filter.clientType == filterType)
                    return;

                console.log("Filter by client type called");
                filter.clientType = filterType;
                updateData(filter);
            }

            function filterDataByTime(start, end) {
                if (filter.timeStart.getTime() == start && filter.timeEnd.getTime() == end)
                    return;

                console.log("Filter by time called");
                filter.timeStart = new Date(start);
                filter.timeEnd = new Date(end);
                updateData(filter);
            }

            function updateData(filter) {
                console.log("Filtering data...");
                const cityTraversalFilter0 = (d) => d.city == d.end;  // within cities
                const cityTraversalFilter1 = (d) => true;                   // both
                const cityTraversalFilter2 = (d) => d.city != d.end;  // between cities

                const clientTypeFilter0 = (d) => true;  // customer
                const clientTypeFilter1 = (d) => true;  // both
                const clientTypeFilter2 = (d) => true;  // subscriber

                let cityTraversalFilter = (filter.cityTraversal == 0) ? cityTraversalFilter0 : ((filter.cityTraversal == 1) ? cityTraversalFilter1 : cityTraversalFilter2);
                let clientTypeFilter = (filter.clientType == 0) ? clientTypeFilter0 : ((filter.clientType == 1) ? clientTypeFilter1 : clientTypeFilter2);

                let dataFiltered = data.filter((d) => {
                    return dateParser(d.start_date) >= filter.timeStart && dateParser(d.end_date) <= filter.timeEnd && cityTraversalFilter(d) && clientTypeFilter(d);
                });
                console.log("Data filtered");

                for (let callback of data_draw_callbacks) {
                    callback(dataFiltered);
                }
            }

            console.log("Preparing filters...");
            // Initial filter state
            changeSlider3ToggleState("#filter-city-traversal", filter.cityTraversal)
            changeSlider3ToggleState("#filter-client-type", filter.clientType)

            // Bind callbacks
            d3.select("#filter-city-traversal").on("data-update", function () {
                filterDataByCityTraversal(this.value)
            });
            d3.select("#filter-city-traversal").on("mouseenter", function() {
                for (let dependent of filter_city_traversal_dependents) {
                    d3.select(dependent)
                        .transition()
                        .duration(500)
                        .style("box-shadow", "0px 0px 25px var(--filter-accent)");
                }
            });
            d3.select("#filter-city-traversal").on("mouseleave", function() {
                for (let dependent of filter_city_traversal_dependents) {
                    d3.select(dependent)
                        .transition()
                        .duration(500)
                        .style("box-shadow", "0px 0px 0px var(--filter-accent)");
                }
            });
            d3.select("#filter-client-type").on("data-update", function () {
                filterDataByClientType(this.value)
            });
            d3.select("#filter-client-type").on("mouseenter", function() {
                for (let dependent of filter_client_type_dependents) {
                    d3.select(dependent)
                        .transition()
                        .duration(500)
                        .style("box-shadow", "0px 0px 25px var(--filter-accent)");
                }
            });
            d3.select("#filter-client-type").on("mouseleave", function() {
                for (let dependent of filter_client_type_dependents) {
                    d3.select(dependent)
                        .transition()
                        .duration(500)
                        .style("box-shadow", "0px 0px 0px var(--filter-accent)");
                }
            });
            let timeSliderBrush = addTimeSlider(filter.timeStart, filter.timeEnd, dateExtent, filterDataByTime);
            console.log("Filters prepared");

            console.log("Initializing visualizations");
            updateData(filter);
        }

        // d3.json("../data/example.json")
        //     .then(draw)
        //     .catch(function(err){console.log(err)});

        console.log("Loading data...");
        d3.csv("../data/trip.csv")
            .then(draw)
            .catch(function(err){console.log(err)});

    </script>
</body>
</html>