<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Bike Share in San Francisco Bay Area</title>
</head>
<body>
    <div id="nav"></div>

    <div id="content" class="vis3-grid">
        <div id="content-traffic">
            <h2>
                Global bike traffic for each
                <select name="content-traffic-class" id="content-traffic-class" autocomplete="off">
                    <option value="city" selected>City</option>
                    <option value="station">Station</option>
                </select>
            </h2>
            
            <p>
                Sort by
                <select name="content-traffic-sort" id="content-traffic-sort" autocomplete="off">
                    <option value="alphabetic" selected>Alphabetic</option>
                    <option value="total_trips">Total trips</option>
                    <option value="incoming_trips">Incoming trips</option>
                    <option value="outgoing_trips">Outgoing trips</option>
                </select>

                <input type="checkbox" name="content-traffic-sort-asc" id="content-traffic-sort-asc" checked>
                Ascending
            </p>

            <div id="content-traffic-vis"></div>
        </div>

        <div id="content-client-total-trips">

            <div id="content-client-total-trips-vis"></div>
        </div>

        <div id="content-bike-usage">

            <div id="content-bike-usage-vis"></div>
        </div>

        <div id="content-client-length-trips">

            <div id="content-client-length-trips-vis"></div>
        </div>
    </div>

    <div id="filters"></div>

    <script src="https://cdn.jsdelivr.net/npm/jquery@3.7.1/dist/jquery.min.js"></script>
    <script src="http://d3js.org/d3.v6.js"></script>
    <script src="base.js"></script>
    <script>

        function visTraffic(metadata) {
            // Set the dimensions and margins of the graph
            const margin = {top: 10, right: 30, bottom: 200, left: 50};
            const width = 600 - margin.left - margin.right;
            const totalWidth = 3 * width;
            const height = 400 - margin.top - margin.bottom;

            const city_graph = d3.select("#content-traffic-vis").append("div");
            const station_graph = d3.select("#content-traffic-vis").append("div")
                .style("display", "none");  // hidden by default

            // Create a scrollable div which will contain the chart and X axis
            const station_scrollable_div = station_graph.append("div")
                    .style("overflow-x", "scroll")
                    .style("-webkit-overflow-scrolling", "touch")
                    .style("position", "absolute")
                    .style("z-index", 1)
                    .style("width", width + "px")
                    .style("height", (height + margin.bottom + margin.top) + "px")
                    .style("left", "60px");

            const station_scrollable_div_svg = station_scrollable_div.append("svg")
                    .attr("width", totalWidth)
                    .attr("height", height + margin.bottom + margin.top)
                    .style("display", "block");

            // Append the svg object to the respective section
            const station_outer_svg = station_graph
                .append("svg")
                .attr("width", width + margin.left + margin.right)
                .attr("height", height + margin.top + margin.bottom)
                .style("top", "0px")
                .append("g")
                .attr("transform", "translate(" + margin.left + "," + margin.top + ")");

            // NOTE: disadvantage of having the same array of stations: all stations will appear even if they have no trips for the given filters
            const stations_id_name_pairs = Object.entries(metadata["stations"]).map((s) => [s[0], s[1]["name"]]);
            const stations_names = stations_id_name_pairs.map((p) => p[1]);
            const stations_ids = stations_id_name_pairs.map((p) => p[0]);

            // Create X scale (necessary for the sorting methods)
            const x = d3.scaleBand()
                .domain(stations_names)
                .range([0, totalWidth])
                .padding([0.2]);

            // Input options callbacks
            d3.select("#content-traffic-class").on("change", function() {
                let traffic_type = this.value;
                switch (traffic_type) {
                    case "city":
                        station_graph.style("display", "none")
                        city_graph.style("display", "block")
                        break;
                
                    case "station":
                        city_graph.style("display", "none")
                        station_graph.style("display", "block")
                        break;

                    default:
                        console.log("ERROR: invalid class for traffic visualization")
                }
            });

            function sortContent(sort_type, sort_ascending) {
                let sorted = undefined;

                switch (sort_type) {
                    case "alphabetic":
                        sorted = station_scrollable_div_svg.selectAll("g.g-out").selectAll("rect")
                            .sort((a, b) => sort_ascending ? d3.ascending(a.station, b.station) : d3.descending(a.station, b.station));
                        break;
                    
                    case "total_trips":
                        sorted = station_scrollable_div_svg.selectAll("g.g-out").selectAll("rect")
                            .sort((a, b) => sort_ascending ? d3.ascending(a.value_in + a.value_out, b.value_in + b.value_out) : d3.descending(a.value_in + a.value_out, b.value_in + b.value_out));
                        break;
                    
                    case "incoming_trips":
                        sorted = station_scrollable_div_svg.selectAll("g").selectAll("rect")
                            .sort((a, b) => sort_ascending ? d3.ascending(a.value_in, b.value_in) : d3.descending(a.value_in, b.value_in));
                        break;

                    case "outgoing_trips":
                        sorted = station_scrollable_div_svg.selectAll("g").selectAll("rect")
                            .sort((a, b) => sort_ascending ? d3.ascending(a.value_out, b.value_out) : d3.descending(a.value_out, b.value_out));
                        break;
                    
                    default:
                        console.log("ERROR: invalid sort type for traffic visualization");
                        return;
                }

                // sorted
                //     .transition()
                //     .attr("x", (d, i) => x(d.station) + x.bandwidth() / 2);
                sorted
                    .transition()
                    // TODO: how do I do this?
                    .attr("x", (d, i) => i);
            }

            // TODO: how do we sort the X-axis? it's not bound to the data
            d3.select("#content-traffic-sort").on("change", function() {
                sortContent(this.value, d3.select("#content-traffic-sort-asc").property("checked"));
            });

            return (data) => {
                // Data processing for outgoing trips
                const start_station_counts = {};
                data.forEach(function(d) {
                    start_station_counts[d.start_station_id] = (start_station_counts[d.start_station_id] || 0) + d.total_trips;
                });
                
                // Data processing for incoming trips
                const end_station_counts = {};
                data.forEach(function(d) {
                    end_station_counts[d.end_station_id] = (end_station_counts[d.end_station_id] || 0) + d.total_trips;
                });

                let counts_data = stations_id_name_pairs.map(function(p) {
                    return { station: p[1], value_out: start_station_counts[p[0]] || 0, value_in: end_station_counts[p[0]] || 0 };
                });

                // Add X axis
                station_scrollable_div_svg.append("g")
                    .attr("transform", "translate(0," + (height + margin.top) + ")")
                    .call(d3.axisBottom(x).tickSize(0))
                    .selectAll("text")
                        .attr("transform", "translate(0,5), rotate(-90)")
                        .style("text-anchor", "end");

                // Add Y axis
                const y = d3.scaleLinear()
                    .domain([0, d3.max(Object.values(start_station_counts).concat(Object.values(end_station_counts)))])
                    .range([height, 0]);

                station_outer_svg.append("g")
                    .call(d3.axisLeft(y));

                // Color palette
                const color = d3.scaleOrdinal()
                    .domain(["start", "end"])
                    .range(['#e41a1c', '#377eb8']);

                // Show the bars for outgoing trips
                station_scrollable_div_svg.append("g")
                    .classed("g-out", true)
                    .selectAll("rect")
                    .data(counts_data)
                    .enter().append("rect")
                    .attr("x", function(d, i) { return x(d.station); })
                    .attr("y", function(d) { return y(d.value_out) + margin.top; })
                    .attr("width", x.bandwidth() / 2)
                    .attr("height", function(d) { return height - y(d.value_out); })
                    .attr("fill", function(d) { return color("start"); });

                // Show the bars for incoming trips
                station_scrollable_div_svg.append("g")
                    .classed("g-in", true)
                    .selectAll("rect")
                    .data(counts_data)
                    .enter().append("rect")
                    .attr("x", function(d, i) { return x(d.station) + x.bandwidth() / 2; })
                    .attr("y", function(d) { return y(d.value_in) + margin.top; })
                    .attr("width", x.bandwidth() / 2)
                    .attr("height", function(d) { return height - y(d.value_in); })
                    .attr("fill", function(d) { return color("end"); });

                // Add Legend
                var legend = station_outer_svg.append("g")
                    .attr("transform", "translate(" + (width - 100) + "," + 20 + ")")
                    .selectAll("g")
                    .data(color.domain().slice().reverse())
                    .enter().append("g")
                    .attr("transform", function(d, i) { return "translate(0," + i * 20 + ")"; });

                legend.append("rect")
                    .attr("width", 18)
                    .attr("height", 18)
                    .attr("fill", color);

                legend.append("text")
                    .attr("x", 24)
                    .attr("y", 9)
                    .attr("dy", ".35em")
                    .style("text-anchor", "start")
                    .text(function(d) { return d === "start" ? "Outgoing" : "Incoming"; });

                // Default sort
                sortContent("alphabetic", true);
                
                station_scrollable_div.node().scrollBy(0, 0);
            };
        }

        function visBikeUsage(metadata) {
            // const width = 500;
            // const height = 300;
            // const margin = 50;

            // const colorOrdinal = d3.scaleOrdinal(d3.schemeCategory10);

            // const svg = d3.select('#content-traffic-vis').append('svg')
            //     .attr('width', width)
            
            // return (dataFiltered) => svg.selectAll("circle")
            //     .data(dataFiltered)
            //     .join("circle")
            //         .attr("cx", (d, i) => 25 + i * 50)
            //         .attr("cy", (d) => d.Numero_de_Alunos)
            //         .attr("r", 10)
            //         .attr("fill", (d) => colorOrdinal(d.city));

            return () => null;
        }

        function visClientTotalTrips(metadata) {
            // Set up SVG dimensions
            const margin = { top: 20, right: 20, bottom: 70, left: 70 };
            const w = 500 - margin.left - margin.right;
            const h = 300 - margin.top - margin.bottom;

            const svg = d3.select("#content-client-total-trips-vis")
                .append("svg")
                .attr("width", w + margin.left + margin.right)
                .attr("height", h + margin.top + margin.bottom)
                .append("g")
                .attr("transform", "translate(" + margin.left + "," + margin.top + ")");

            // TODO: just adding elements on data updates instead of actually updating what's already there
            return (data) => {
                // Extract the subscription_type column
                let subscriptionTypes = data.map(function(d) {
                    return d.subscription_type;
                });

                // Count occurrences of each label
                let labelCounts = {};
                subscriptionTypes.forEach(function(label) {
                    labelCounts[label] = (labelCounts[label] || 0) + 1;
                });

                let maxCount = Math.max(...Object.values(labelCounts));

                // Create rectangles based on the counts
                var rects = svg.selectAll("rect")
                    .data(Object.entries(labelCounts))
                    .join("rect")
                    .attr("x", function (d, i) {
                        return (i * (w / Object.keys(labelCounts).length));
                    })  
                    .attr("y", function (d) {
                        return h - (h * d[1] / maxCount);
                    })
                    .attr("width", (w / Object.keys(labelCounts).length - 1))
                    .attr("height", function (d) {
                        return (h * d[1] / maxCount);
                    })
                    .attr("fill", function (d) {
                        return "rgb(0, 100, " + Math.round((d[1] / maxCount) * 255) + ")";
                    });

                // Create x and y scales
                var xScale = d3.scaleBand()
                    .domain(d3.range(Object.keys(labelCounts).length))
                    .range([0, w])
                    .padding(0.1);

                var yScale = d3.scaleLinear()
                    .domain([0, maxCount])
                    .range([h, 0]);

                // Create x and y axes
                var xAxis = d3.axisBottom(xScale);
                var yAxis = d3.axisLeft(yScale);

                // Append x and y axes to the SVG
                svg.append("g")
                    .attr("transform", "translate(0," + h + ")")
                    .call(xAxis);

                svg.append("g")
                    .call(yAxis);

                // Add title to the chart
                svg.append("text")
                    .attr("x", w / 2)
                    .attr("y", -margin.top / 2.3)
                    .attr("text-anchor", "middle")
                    .style("font-size", "16px")
                    .text("Subscription Types Occurrences");

                // Add Y-axis title
                svg.append("text")
                    .attr("transform", "rotate(-90)")
                    .attr("y", -margin.left + 10)
                    .attr("x", -h / 2)
                    .attr("dy", "1em")
                    .style("text-anchor", "middle")
                    .style("font-size", "14px")
                    .text("Count");

                // Add legend
                let legend = svg.selectAll(".legend")
                    .data(Object.entries(labelCounts))
                    .join("g")
                    .attr("class", "legend")
                    .attr("transform", function(d, i) {
                        return "translate(0," + i * 20 + ")";
                    });

                legend.append("rect")
                    .attr("x", w - 18)
                    .attr("width", 18)
                    .attr("height", 18)
                    .style("fill", function(d) {
                        return "rgb(0, 100, " + Math.round((d[1] / maxCount) * 255) + ")";
                    });

                legend.append("text")
                    .attr("x", w - 24)
                    .attr("y", 9)
                    .attr("dy", ".35em")
                    .style("text-anchor", "end")
                    .text(function(d) {
                        return d[0] ;
                    });
            };
        }

        function visClientLengthTrips(metadata) {
            return () => null;
        }

        function drawTripData(metadata, data, update_callbacks) {
            console.log("Loaded trip data");

            const dateParser = d3.utcParse("%Y-%-m-%-d");

            for (const d of data) {
                d["start_date"] = dateParser(d["start_date"]);
                d["end_date"] = dateParser(d["end_date"]);
                d["duration_avg"] = +d["duration_avg"];
                d["total_trips"] = +d["total_trips"];
            }

            function updateData() {
                console.log("Filtering data...");
                // TODO: include city information on trips, only have station
                const cityTraversalFilter0 = (d) => d.start_station_id == d.end_station_id;  // within cities
                const cityTraversalFilter1 = (d) => true;  // both
                const cityTraversalFilter2 = (d) => d.start_station_id != d.end_station_id;  // between cities

                const clientTypeFilter0 = (d) => d.subscription_type == "Customer";  // customer
                const clientTypeFilter1 = (d) => true;  // both
                const clientTypeFilter2 = (d) => d.subscription_type == "Subscriber";  // subscriber

                let cityTraversalFilter = (filter.cityTraversal == 0) ? cityTraversalFilter0 : ((filter.cityTraversal == 1) ? cityTraversalFilter1 : cityTraversalFilter2);
                let clientTypeFilter = (filter.clientType == 0) ? clientTypeFilter0 : ((filter.clientType == 1) ? clientTypeFilter1 : clientTypeFilter2);

                let dataFiltered = data.filter((d) => {
                    return d.start_date >= filter.timeStart && d.end_date <= filter.timeEnd && cityTraversalFilter(d) && clientTypeFilter(d);
                });
                console.log("Data filtered");

                update_callbacks.forEach((callback) => callback(dataFiltered));
            }

            console.log("Initializing visualizations (trip data)");
            d3.select("#content").on("data-update", updateData);
            updateData();
        }

        console.log("Loading data...");

        trip_small_data = d3.csv("../data/trip_small.csv");

        // TODO: possible performance optimization: (pre-)sort trip data by date. With this, we don't need to filter, we can just use indexOf() and get the indices of the initial and end dates, and finally take the interval in between those indices (hint: use d3.bisector!)
        d3.json("../data/metadata.json")
            .then((metadata) => {
                setupFilters(metadata,
                    ["#content-traffic", "#content-client-total-trips", "#content-client-length-trips"],
                    ["#content-traffic", "#content-client-total-trips", "#content-client-length-trips"],  // NOTE: ideally the client-* graphs shouldn't be here, but it complicates stuff too much otherwise...
                    ["#content-traffic", "#content-client-total-trips", "#content-client-length-trips", "#content-bike-usage"]
                );

                const trip_data_draw_callbacks = [
                    // visBikeUsage(),
                    visTraffic(metadata),
                    visClientTotalTrips(metadata),
                    visClientLengthTrips(metadata)
                ];

                trip_small_data
                    .then((data) => drawTripData(metadata, data, trip_data_draw_callbacks))
                    .catch(function(err){console.log(err)});
            })
            .catch(function(err){console.log(err)});            

    </script>
</body>
</html>