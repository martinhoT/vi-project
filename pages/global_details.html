<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Bike Share in San Francisco Bay Area</title>
</head>
<body>
    <div id="nav"></div>

    <div id="content" class="vis3-grid">
        <div id="content-traffic">
            <h2>
                Global bike traffic for each
                <select name="content-traffic-class" id="content-traffic-class">
                    <option value="city">City</option>
                    <option value="station">Station</option>
                </select>
            </h2>
            
            <p>
                Sort by
                <select name="content-traffic-sort" id="content-traffic-sort">
                    <option value="alphabetic">Alphabetic</option>
                    <option value="total_trips">Total trips</option>
                    <option value="incoming_trips">Incoming trips</option>
                    <option value="outgoing_trips">Outgoing trips</option>
                </select>

                <input type="checkbox" name="content-traffic-sort-asc" id="content-traffic-sort-asc" checked>
                Ascending
            </p>

            <div id="content-traffic-vis"></div>
        </div>

        <div id="content-client-total-trips">

            <div id="content-client-total-trips-vis"></div>
        </div>

        <div id="content-bike-usage">

            <div id="content-bike-usage-vis"></div>
        </div>

        <div id="content-client-length-trips">

            <div id="content-client-length-trips-vis"></div>
        </div>
    </div>

    <div id="filters">
        <div id="filter-city-traversal" class="filter-group">
            <div class="filter-label-left">Within <br> cities</div>
            <div class="slider-3-toggle">
                <div class="slider-3-toggle-middle-indicator"></div>
    
                <div class="slider-3-toggle-circle"></div>
    
                <div class="slider-3-toggle-clickable-areas">
                    <div class="slider-3-toggle-clickable-area-0"></div>
                    <div class="slider-3-toggle-clickable-area-1"></div>
                    <div class="slider-3-toggle-clickable-area-2"></div>
                </div>
            </div>
            <div class="filter-label-right">Between <br> cities</div>
        </div>

        <div id="filter-client-type" class="filter-group">
            <div class="filter-label-left">Customer</div>
            <div class="slider-3-toggle">
                <div class="slider-3-toggle-middle-indicator"></div>
    
                <div class="slider-3-toggle-circle"></div>
    
                <div class="slider-3-toggle-clickable-areas">
                    <div class="slider-3-toggle-clickable-area-0"></div>
                    <div class="slider-3-toggle-clickable-area-1"></div>
                    <div class="slider-3-toggle-clickable-area-2"></div>
                </div>
            </div>
            <div class="filter-label-right">Subscriber</div>
        </div>

        <div id="filter-time">
        </div>
    </div>

    <script src="https://cdn.jsdelivr.net/npm/jquery@3.7.1/dist/jquery.min.js"></script>
    <script src="http://d3js.org/d3.v6.js"></script>
    <script src="base.js"></script>
    <script>

        // Whenever the filters change, dispatch the custom event 'data-update' with the appropriate details.
        // D3 will listen for these events
        // const dataUpdateEvent = new CustomEvent('data-update', {detail: ...});

        // JS
        // Set filters' default values and get the filters' values if passed on the URL
        // The null dates will be set when the data is obtained and extents are extracted
        const filter = {
            cityTraversal: 0,
            clientType: 0,
            timeStart: null,
            timeEnd: null
        }
        for (const [key, value] of currentURL.searchParams) {
            let parsedValue = null;

            // Number
            if (["cityTraversal", "clientType"].includes(key))
                parsedValue = +value;

            // Date
            else if (["timeStart", "timeEnd"].includes(key))
                parsedValue = new Date(+value);

            if (parsedValue != null)
                filter[key] = parsedValue
        }

        const changeSlider3ToggleState = function(filterId, state) {
            let left_position = 5 + 35 * state;
            // TODO: animation
            $(filterId).children(".slider-3-toggle").children(".slider-3-toggle-circle").css("left", left_position + "px");

            // Change the labels' color
            if (state <= 1) {
                $(filterId).children(".filter-label-left").css("color", "#0CA789");
            }
            else {
                $(filterId).children(".filter-label-left").css("color", "#000000");
            }

            if (state >= 1) {
                $(filterId).children(".filter-label-right").css("color", "#0CA789");
            }
            else {
                $(filterId).children(".filter-label-right").css("color", "#000000");
            }
            
            let filterElem = document.getElementById(filterId.slice(1));
            let changed = filterElem.value != state;
            filterElem.value = state;
            if (changed) {
                if (filterId == "#filter-city-traversal") {
                    filter.cityTraversal = state;
                    console.log("Filter by city traversal");
                }
                else if (filterId == "#filter-client-type") {
                    filter.clientType = state;
                    console.log("Filter by client type");
                }

                document.getElementById("content").dispatchEvent(new Event('data-update'));
            }
        }

        const sliderFilters = ["#filter-city-traversal", "#filter-client-type"];
        const filter_city_traversal_dependents = ["#content-traffic", "#content-client-total-trips", "#content-client-length-trips"];
        const filter_client_type_dependents = ["#content-traffic"];
        const filter_time_dependents = ["#content-traffic", "#content-client-total-trips", "#content-client-length-trips", "#content-bike-usage"];

        $(document).ready(function() {
            $("#filters").show();

            for (let filter of sliderFilters) {
                for (let i = 0; i < 3; i++) {
                    $(filter).children(".slider-3-toggle").children(".slider-3-toggle-clickable-areas").children(".slider-3-toggle-clickable-area-" + i).on("click", function() {
                        changeSlider3ToggleState(filter, i);
                    })
                }
            }
        });

        // D3

        // TODO: on brush single-click it disappears, let it stay?
        function addTimeSlider(initialLeft, initialRight, domain) {
            const timeSliderWidth = 200
            const timeSliderHeight = 20
            const timeSliderLabelWidth = 100

            let timeFilterSvg = d3.select('#filter-time').append('svg')
                .attr('width', timeSliderWidth + timeSliderLabelWidth * 2)
                .attr('height', timeSliderHeight)

            const timeSlider = timeFilterSvg.append('g')

            let x = d3.scaleLinear()
                .domain(domain)
                .range([0, timeSliderWidth])

            timeSlider.selectAll('text')
                .data([[0, 15], [timeSliderWidth + timeSliderLabelWidth, 15]])
                .join('text')
                    .text('A')
                    .attr('x', (d) => d[0])
                    .attr('y', (d) => d[1])

            var brush = d3.brushX()
                .extent([[0, 0], [timeSliderWidth, timeSliderHeight]])
                .on('brush', brushed)
                .on('end', brushEnded)

            var brushGroup = timeFilterSvg.append('g')
                .attr('class', 'brush')
                .attr('transform', 'translate(' + timeSliderLabelWidth + ',' + 0 + ')')
                .call(brush)
            
            function brushed(event) {
                // Alternative: let selection = event.selection
                let selection = d3.brushSelection(this)
                if (selection == null)
                    return

                let range = selection.map(x.invert)
                
                timeSlider.selectAll("text")
                    .text(function(d, i) {
                        let date = new Date(range[i]);
                        return `${date.getUTCDate()}/${date.getUTCMonth() + 1}/${date.getUTCFullYear()}`
                    })
                
                // NOTE: comment if update every brush action is too heavy, and use brushEnded instead
                // callback(range[0], range[1])
            }

            function brushEnded() {
                let selection = d3.brushSelection(this)
                if (selection == null)
                    return

                let range = selection.map(x.invert)

                if (filter.timeStart.getTime() == range[0] && filter.timeEnd.getTime() == range[1])
                    return;

                filter.timeStart = new Date(range[0]);
                filter.timeEnd = new Date(range[1]);
                console.log("Filter by time");

                document.getElementById("content").dispatchEvent(new Event('data-update'));
            }

            brush.move(brushGroup, [initialLeft, initialRight].map(x));

            return brush
        }

        function visTraffic(metadata) {
            // Set the dimensions and margins of the graph
            const margin = {top: 10, right: 30, bottom: 200, left: 50};
            const width = 600 - margin.left - margin.right;
            const totalWidth = 3 * width;
            const height = 400 - margin.top - margin.bottom;

            // Create a scrollable div which will contain the chart and X axis
            const scrollable_div = d3.select("#content-traffic-vis").append("div")
                    .style("overflow-x", "scroll")
                    .style("-webkit-overflow-scrolling", "touch")
                    .style("position", "absolute")
                    .style("z-index", 1)
                    .style("width", width + "px")
                    .style("height", (height + margin.bottom + margin.top) + "px")
                    .style("left", "60px");

            const scrollable_div_svg = scrollable_div.append("svg")
                    .attr("width", totalWidth)
                    .attr("height", height + margin.bottom + margin.top)
                    .style("display", "block");

            // Append the svg object to the respective section
            const outer_svg = d3.select("#content-traffic-vis")
                .append("svg")
                .attr("width", width + margin.left + margin.right)
                .attr("height", height + margin.top + margin.bottom)
                .style("top", "0px")
                .append("g")
                .attr("transform", "translate(" + margin.left + "," + margin.top + ")");

            // NOTE: disadvantage of having the same array of stations: all stations will appear even if they have no trips for the given filters
            const stations_id_name_pairs = Object.entries(metadata["stations"]).map((s) => [s[0], s[1]["name"]]);
            const stations_names = stations_id_name_pairs.map((p) => p[1]);
            const stations_ids = stations_id_name_pairs.map((p) => p[0]);

            return (data) => {
                // Data processing for outgoing trips
                const start_station_counts = {};
                data.forEach(function(d) {
                    start_station_counts[d.start_station_id] = (start_station_counts[d.start_station_id] || 0) + d.total_trips;
                });
                
                // Data processing for incoming trips
                const end_station_counts = {};
                data.forEach(function(d) {
                    end_station_counts[d.end_station_id] = (end_station_counts[d.end_station_id] || 0) + d.total_trips;
                });

                debugger;

                // Add X axis
                const x = d3.scaleBand()
                    .domain(stations_names)
                    .range([0, totalWidth])
                    .padding([0.2]);

                scrollable_div_svg.append("g")
                    .attr("transform", "translate(0," + (height + margin.top) + ")")
                    .call(d3.axisBottom(x).tickSize(0))
                    .selectAll("text")
                        .attr("transform", "translate(10,5), rotate(-70)")
                        .style("text-anchor", "end");

                // Add Y axis
                const y = d3.scaleLinear()
                    .domain([0, d3.max(Object.values(start_station_counts).concat(Object.values(end_station_counts)))])
                    .range([height, 0]);

                outer_svg.append("g")
                    .call(d3.axisLeft(y));

                // Color palette
                const color = d3.scaleOrdinal()
                    .domain(["start", "end"])
                    .range(['#e41a1c', '#377eb8']);

                // Show the bars for outgoing trips
                scrollable_div_svg.append("g")
                    .selectAll("rect")
                    .data(stations_id_name_pairs.map(function(p) {
                        return { station: p[1], value: start_station_counts[p[0]] || 0, type: "start" };
                    }))
                    .enter().append("rect")
                    .attr("x", function(d) { return x(d.station); })
                    .attr("y", function(d) { return y(d.value) + margin.top; })
                    .attr("width", x.bandwidth() / 2)
                    .attr("height", function(d) { return height - y(d.value); })
                    .attr("fill", function(d) { return color(d.type); });

                // Show the bars for incoming trips
                scrollable_div_svg.append("g")
                    .selectAll("rect")
                    .data(stations_id_name_pairs.map(function(p) {
                        return { station: p[1], value: end_station_counts[p[0]] || 0, type: "end" };
                    }))
                    .enter().append("rect")
                    .attr("x", function(d) { return x(d.station) + x.bandwidth() / 2; })
                    .attr("y", function(d) { return y(d.value) + margin.top; })
                    .attr("width", x.bandwidth() / 2)
                    .attr("height", function(d) { return height - y(d.value); })
                    .attr("fill", function(d) { return color(d.type); });

                // Add Legend
                var legend = outer_svg.append("g")
                    .attr("transform", "translate(" + (width - 100) + "," + 20 + ")")
                    .selectAll("g")
                    .data(color.domain().slice().reverse())
                    .enter().append("g")
                    .attr("transform", function(d, i) { return "translate(0," + i * 20 + ")"; });

                legend.append("rect")
                    .attr("width", 18)
                    .attr("height", 18)
                    .attr("fill", color);

                legend.append("text")
                    .attr("x", 24)
                    .attr("y", 9)
                    .attr("dy", ".35em")
                    .style("text-anchor", "start")
                    .text(function(d) { return d === "start" ? "Outgoing" : "Incoming"; });

                scrollable_div.node().scrollBy(totalWidth, 0);
            };
        }

        function visBikeUsage(metadata) {
            // const width = 500;
            // const height = 300;
            // const margin = 50;

            // const colorOrdinal = d3.scaleOrdinal(d3.schemeCategory10);

            // const svg = d3.select('#content-traffic-vis').append('svg')
            //     .attr('width', width)
            
            // return (dataFiltered) => svg.selectAll("circle")
            //     .data(dataFiltered)
            //     .join("circle")
            //         .attr("cx", (d, i) => 25 + i * 50)
            //         .attr("cy", (d) => d.Numero_de_Alunos)
            //         .attr("r", 10)
            //         .attr("fill", (d) => colorOrdinal(d.city));

            return () => null;
        }

        function visClientTotalTrips(metadata) {
            // Set up SVG dimensions
            const margin = { top: 20, right: 20, bottom: 70, left: 70 };
            const w = 500 - margin.left - margin.right;
            const h = 300 - margin.top - margin.bottom;

            const svg = d3.select("#content-client-total-trips-vis")
                .append("svg")
                .attr("width", w + margin.left + margin.right)
                .attr("height", h + margin.top + margin.bottom)
                .append("g")
                .attr("transform", "translate(" + margin.left + "," + margin.top + ")");

            // TODO: just adding elements on data updates instead of actually updating what's already there
            return (data) => {
                // Extract the subscription_type column
                let subscriptionTypes = data.map(function(d) {
                    return d.subscription_type;
                });

                // Count occurrences of each label
                let labelCounts = {};
                subscriptionTypes.forEach(function(label) {
                    labelCounts[label] = (labelCounts[label] || 0) + 1;
                });

                let maxCount = Math.max(...Object.values(labelCounts));

                // Create rectangles based on the counts
                var rects = svg.selectAll("rect")
                    .data(Object.entries(labelCounts))
                    .join("rect")
                    .attr("x", function (d, i) {
                        return (i * (w / Object.keys(labelCounts).length));
                    })  
                    .attr("y", function (d) {
                        return h - (h * d[1] / maxCount);
                    })
                    .attr("width", (w / Object.keys(labelCounts).length - 1))
                    .attr("height", function (d) {
                        return (h * d[1] / maxCount);
                    })
                    .attr("fill", function (d) {
                        return "rgb(0, 100, " + Math.round((d[1] / maxCount) * 255) + ")";
                    });

                // Create x and y scales
                var xScale = d3.scaleBand()
                    .domain(d3.range(Object.keys(labelCounts).length))
                    .range([0, w])
                    .padding(0.1);

                var yScale = d3.scaleLinear()
                    .domain([0, maxCount])
                    .range([h, 0]);

                // Create x and y axes
                var xAxis = d3.axisBottom(xScale);
                var yAxis = d3.axisLeft(yScale);

                // Append x and y axes to the SVG
                svg.append("g")
                    .attr("transform", "translate(0," + h + ")")
                    .call(xAxis);

                svg.append("g")
                    .call(yAxis);

                // Add title to the chart
                svg.append("text")
                    .attr("x", w / 2)
                    .attr("y", -margin.top / 2.3)
                    .attr("text-anchor", "middle")
                    .style("font-size", "16px")
                    .text("Subscription Types Occurrences");

                // Add Y-axis title
                svg.append("text")
                    .attr("transform", "rotate(-90)")
                    .attr("y", -margin.left + 10)
                    .attr("x", -h / 2)
                    .attr("dy", "1em")
                    .style("text-anchor", "middle")
                    .style("font-size", "14px")
                    .text("Count");

                // Add legend
                let legend = svg.selectAll(".legend")
                    .data(Object.entries(labelCounts))
                    .join("g")
                    .attr("class", "legend")
                    .attr("transform", function(d, i) {
                        return "translate(0," + i * 20 + ")";
                    });

                legend.append("rect")
                    .attr("x", w - 18)
                    .attr("width", 18)
                    .attr("height", 18)
                    .style("fill", function(d) {
                        return "rgb(0, 100, " + Math.round((d[1] / maxCount) * 255) + ")";
                    });

                legend.append("text")
                    .attr("x", w - 24)
                    .attr("y", 9)
                    .attr("dy", ".35em")
                    .style("text-anchor", "end")
                    .text(function(d) {
                        return d[0] ;
                    });
            };
        }

        function visClientLengthTrips(metadata) {
            return () => null;
        }

        // TODO: possible performance optimization: (pre-)sort trip data by date. With this, we don't need to filter, we can just use indexOf() and get the indices of the initial and end dates, and finally take the interval in between those indices
        function setupVisualizations(metadata) {
            const dateParser = d3.utcParse("%Y-%-m-%-d");
            let dateExtent = [dateParser(metadata["date_min"]), dateParser(metadata["date_max"])];
            
            if (filter.timeStart == null)
                filter.timeStart = dateExtent[0];
            if (filter.timeEnd == null)
                filter.timeEnd = dateExtent[1];

            // Highlight graphs that are affected by the filter
            function highlight_start(elements) {
                for (let element of elements) {
                    d3.select(element)
                        .transition()
                        .duration(500)
                        .style("box-shadow", "0px 0px 25px var(--filter-accent)");
                }
            }
            function highlight_stop(elements) {
                for (let element of elements) {
                    d3.select(element)
                        .transition()
                        .duration(500)
                        .style("box-shadow", "0px 0px 0px var(--filter-accent)");
                }
            }
            d3.select("#filter-city-traversal").on("mouseenter", function() {
                highlight_start(filter_city_traversal_dependents);
            });
            d3.select("#filter-city-traversal").on("mouseleave", function() {
                highlight_stop(filter_city_traversal_dependents);
            });
            d3.select("#filter-client-type").on("mouseenter", function() {
                highlight_start(filter_client_type_dependents);
            });
            d3.select("#filter-client-type").on("mouseleave", function() {
                highlight_stop(filter_client_type_dependents);
            });
            d3.select("#filter-time").on("mouseenter", function() {
                highlight_start(filter_time_dependents);
            });
            d3.select("#filter-time").on("mouseleave", function() {
                highlight_stop(filter_time_dependents);
            });

            console.log("Preparing filters...");
            // Initial filter state
            changeSlider3ToggleState("#filter-city-traversal", filter.cityTraversal)
            changeSlider3ToggleState("#filter-client-type", filter.clientType)

            let timeSliderBrush = addTimeSlider(filter.timeStart, filter.timeEnd, dateExtent);
            console.log("Filters prepared");
        }

        // Trip data
        // TODO: client type filter is affecting visualizations that it shouldn't as well
        function drawTripData(metadata, data, update_callbacks) {
            console.log("Loaded trip data");

            const dateParser = d3.utcParse("%Y-%-m-%-d");
            const dateExtent = [dateParser(metadata["date_min"]), dateParser(metadata["date_max"])];

            for (const d of data) {
                d["start_date"] = dateParser(d["start_date"]);
                d["end_date"] = dateParser(d["end_date"]);
                d["duration_avg"] = +d["duration_avg"];
                d["total_trips"] = +d["total_trips"];
            }

            function updateData() {
                console.log("Filtering data...");
                // TODO: include city information on trips, only have station
                const cityTraversalFilter0 = (d) => d.start_station_id == d.end_station_id;  // within cities
                const cityTraversalFilter1 = (d) => true;  // both
                const cityTraversalFilter2 = (d) => d.start_station_id != d.end_station_id;  // between cities

                const clientTypeFilter0 = (d) => d.subscription_type == "Customer";  // customer
                const clientTypeFilter1 = (d) => true;  // both
                const clientTypeFilter2 = (d) => d.subscription_type == "Subscriber";  // subscriber

                let cityTraversalFilter = (filter.cityTraversal == 0) ? cityTraversalFilter0 : ((filter.cityTraversal == 1) ? cityTraversalFilter1 : cityTraversalFilter2);
                let clientTypeFilter = (filter.clientType == 0) ? clientTypeFilter0 : ((filter.clientType == 1) ? clientTypeFilter1 : clientTypeFilter2);

                let dataFiltered = data.filter((d) => {
                    return d.start_date >= filter.timeStart && d.end_date <= filter.timeEnd && cityTraversalFilter(d) && clientTypeFilter(d);
                });
                console.log("Data filtered");

                for (const callback of update_callbacks) {
                    callback(dataFiltered);
                }
            }

            console.log("Initializing visualizations (trip data)");
            d3.select("#content").on("data-update", updateData);
            updateData();
        }

        console.log("Loading data...");

        trip_small_data = d3.csv("../data/trip_small.csv");

        d3.json("../data/metadata.json")
            .then((metadata) => {
                setupVisualizations(metadata);

                const trip_data_draw_callbacks = [
                    // visBikeUsage(),
                    visTraffic(metadata),
                    visClientTotalTrips(metadata),
                    visClientLengthTrips(metadata)
                ]

                trip_small_data
                    .then((data) => drawTripData(metadata, data, trip_data_draw_callbacks))
                    .catch(function(err){console.log(err)});
            })
            .catch(function(err){console.log(err)});            

    </script>
</body>
</html>